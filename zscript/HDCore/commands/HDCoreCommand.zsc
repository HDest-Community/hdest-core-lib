class HDCoreCommand {
    name command;

    Map<name, HDCoreCommandParam> params;

    static HDCoreCommand create(name command, string paramsStr = "") {
        let cmd = HDCoreCommand(new('HDCoreCommand'));

        if (cmd) {
            cmd.command = command;
            cmd.params.clear();

            parseParams(cmd.params, paramsStr);
        }

        return cmd;
    }

    static void parseParams(out Map<name, HDCoreCommandParam> paramsMap, string paramsStr = "") {
        if (paramsStr.length() > 0) {

            let dict = Dictionary.fromString(paramsStr);
            let i = DictionaryIterator.create(dict);

            while (i.next()) {

                // Default to a basic Static Value Provider
                let providerClassName = "HDCoreStaticProvider";
                let key = i.key();
                let val = i.value();

                // Detect any delegate values and defer to their Providers
                if (val.indexOf("$") == 0) {
                    providerClassName = "HDCoreLocalizedStringProvider";
                    val = val.mid(1);
                } else if (val.indexOf("#") == 0) {
                    providerClassName = "HDCoreCVarProvider";
                    val = val.mid(1);
                } else if (val.indexOf("@") == 0) {
                    providerClassName = "HDCoreFunctionProvider_"..val.mid(1);
                    val = paramsStr;
                }

                // If the specific Provider Class doesn't exist, quit.
                // This is mainly for custom Function Providers,
                // but may be useful in the future
                if (!HDCore.checkClassExists(providerClassName)) {
                    HDCore.log('HDCoreLib.Command.parseParams', LOGGING_WARN, "Unknown Data Provider: '"..providerClassName.."'!");

                    return;
                }

                // If we're building a Nested Provider Class, pass in the param prefix
                // to filter out irrelevant parameters.
                let provider = providerClassName.indexOf("HDCoreFunctionProvider_") == 0
                    ? HDCoreFunctionProvider.create(providerClassName, key, val)
                    : HDCoreDataProvider.create(providerClassName, val);

                if (provider) {
                    let param = HDCoreCommandParam.create(key, provider);
    
                    if (param) {
                        paramsMap.insert(key, param);
                    }
                }
            }
        }
    }

    bool hasParam(string key) {
        let v = params.checkKey(key);
        HDCore.log("HDCoreLib."..GetClassName().."."..command, LOGGING_TRACE, "hasParam(\""..key.."\") => "..v);
        return v;
    }

    HDCoreCommandParam getParam(string key) {
        let v = HDCoreCommandParam(params.getIfExists(key));
        HDCore.log("HDCoreLib."..GetClassName().."."..command, LOGGING_TRACE, "getParam(\""..key.."\") => "..v.toString());
        return v;
    }

    HDCoreDataProvider getParamValue(string key, HDCoreDataProvider defaultValue = null) {
        let v = hasParam(key) ? getParam(key)._value : defaultValue;
        HDCore.log("HDCoreLib."..GetClassName().."."..command, LOGGING_TRACE, "getParamValue(\""..key.."\") => "..(v ? v.toString() : "null"));
        return v;
    }

    string getStringParam(string key, string defaultValue = "") {
        let v = hasParam(key) ? getParam(key).getStringValue() : defaultValue;
        HDCore.log("HDCoreLib."..GetClassName().."."..command, LOGGING_TRACE, "getStringParam(\""..key.."\", \""..defaultValue.."\") => "..v);
        return v;
    }

    name getNameParam(string key, name defaultValue = '') {
        let v = hasParam(key) ? getParam(key).getNameValue() : defaultValue;
        HDCore.log("HDCoreLib."..GetClassName().."."..command, LOGGING_TRACE, "getNameParam(\""..key.."\", \""..defaultValue.."\") => "..v);
        return v;
    }

    int getIntParam(string key, int defaultValue = 0) {
        let v = hasParam(key) ? getParam(key).getIntValue() : defaultValue;
        HDCore.log("HDCoreLib."..GetClassName().."."..command, LOGGING_TRACE, "getIntParam(\""..key.."\", \""..defaultValue.."\") => "..v);
        return v;
    }

    double getDoubleParam(string key, double defaultValue = 0.0) {
        let v = hasParam(key) ? getParam(key).getDoubleValue() : defaultValue;
        HDCore.log("HDCoreLib."..GetClassName().."."..command, LOGGING_TRACE, "getDoubleParam(\""..key.."\", \""..defaultValue.."\") => "..v);
        return v;
    }

    bool getBoolParam(string key, bool defaultValue = false) {
        let v = hasParam(key) ? getParam(key).getBoolValue() : defaultValue;
        HDCore.log("HDCoreLib."..GetClassName().."."..command, LOGGING_TRACE, "getBoolParam(\""..key.."\", \""..defaultValue.."\") => "..v);
        return v;
    }

    bool equals(HDCoreCommand other) {
        HDCore.log("HDCoreLib."..GetClassName().."."..command, LOGGING_TRACE, "equals(\""..other.toString().."\")...");

        // First check if the command and size of params are equal
        let isEqual = command == other.command && params.countUsed() == other.params.countUsed();

        // If they are, check if each param matches the other, and quit early if they are not
        if (isEqual) forEach(k, v : params) if (!other.params.checkKey(k) || other.params.getIfExists(k) != v) return false;

        HDCore.log("HDCoreLib."..GetClassName().."."..command, LOGGING_TRACE, "equals(\""..other.toString().."\") => "..isEqual);

        return isEqual;
    }

    string toString() {
        let paramStr = "(";

        forEach (k, v : params) paramStr = paramStr.."\""..k.."\": "..HDCoreCommandParam(v).getStringValue()..", ";

        paramStr = paramStr..")";

        return String.format(
            "{ \"command\": \"%s\", \"params\": \"%s\" }",
                 command,             paramStr
        );
    }
}

