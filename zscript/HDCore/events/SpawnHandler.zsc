class HDCoreSpawnHandler : EventHandler {

    // List of persistent classes to completely ignore.
    // This -should- mean this mod has no performance impact.
    static const string blacklist[] = {
        'HDSmoke',
        'BloodTrail',
        'CheckPuff',
        'WallChunk',
        'HDBulletPuff',
        'HDFireballTail',
        'ReverseImpBallTail',
        'HDSmokeChunk',
        'ShieldSpark',
        'HDFlameRed',
        'HDMasterBlood',
        'PlantBit',
        'HDBulletActor',
        'HDLadderSection'
    };

    // List of all spawn tables.
    Array<HDCoreSpawnTable> spawnTables;

    bool initialized;

    HDCoreSpawnTable getSpawnTable(name name, bool persists = false, bool replace = true) {
        if (spawnTables.size()) {
            foreach (table : spawnTables) {
                if ((table.tableName == name || table.spawnName == name) && table.isPersistent == persists && table.replace == replace) {
                    return table;
                }
            }
        }

        return null;
    }

    void getSpawnTables(out Array<HDCoreSpawnTable> tables, name name, bool replace = true) {
        if (spawnTables.size()) {
            foreach (table : spawnTables) {
                if ((table.tableName == name || table.spawnName == name) && table.replace == replace) {
                    tables.push(table);
                }
            }
        }
    }

    // Appends the given Spawn Table with the handler, or registers it if it does not yet exist
    void addSpawnTable(HDCoreSpawnTable table) {

        if (hd_debug) {

            let msg = "Adding "
                ..(table.isPersistent ? "Persistent" : "Non-Persistent").." "
                ..(table.replace ? "Replacement" : "Spawning")
                .." Table for "..table.spawnName.." named '"..table.tableName
                .."': [";

                if (table.entries.size()) foreach (entry : table.entries) msg = msg..", "..entry.toString();

            console.printf(msg.."]");
        }

        // If we find an existing table, simply append the entries
        if (spawnTables.size()) {
            foreach (spawnTable : spawnTables) {
                if (table.equals(spawnTable)) {
                    spawnTable.entries.append(table.entries);

                    return;
                }
            }
        }

        // Otherwise, add the table to the registry.
        spawnTables.push(table);
    }

    // Add a new entry to an existing Spawn Table
    void addSpawnTableEntry(name name, HDCoreSpawnTableEntry entry, bool persists = false, bool replace = true) {
        Array<HDCoreSpawnTable> tables;
        tables.clear();

        getSpawnTables(tables, name, replace);
        foreach (spawnTable : tables) if (spawnTable.isPersistent == persists) spawnTable.addEntry(entry);
    }

    // Tries to replace the item during spawning.
    bool tryReplaceThing(ReplaceEvent e, HDCoreSpawnTable table) {
        Array<int> weights;
        weights.clear();

        table.getWeights(weights);

        let entry = table.entries[HDCore.getWeightedRandom(weights)];

        if (entry && entry.name != e.replacee) {
            if (hd_debug) console.printf(e.replacee.getClassName().." -> "..entry.name);

            e.replacement = entry.name;

            return true;
        }

        return false;
    }

    // Tries to create the Enemy via random spawning.
    bool tryCreateThing(Actor a, HDCoreSpawnTable table) {
        Array<int> weights;
        weights.clear();

        table.getWeights(weights);

        let entry = table.entries[HDCore.getWeightedRandom(weights)];

        if (entry && entry.name != a.getClassName()) {
            if (hd_debug) console.printf(a.getClassName().." + "..entry.name);

            Actor.Spawn(entry.name, a.pos);

            return true;
        }

        return false;
    }

    void init() {
        if (initialized) return;

        spawnTables.clear();

        Array<string> hdcInfoLump;
        hdcInfoLump.clear();

        HDCore.readHDCoreInfo(hdcInfoLump);

        Array<HDCoreInfoLumpCommand> cmds;
        cmds.clear();

        HDCore.parseHDCoreInfo(hdcInfoLump, cmds);

        if (hd_debug) forEach(cmd : cmds) console.printF(cmd.toString());
        
        loadSpawnTables(cmds);

        if (hd_debug) forEach(table : spawnTables) console.printF(table.toString());

        initialized = true;
    }

    void loadSpawnTables(Array<HDCoreInfoLumpCommand> cmds) {
        forEach (cmd : cmds) {
            switch (cmd.command) {
                case 'newSpawnTable':
                    let table = HDCoreSpawnTable.create(
                        cmd.getNameArg("spawnName"),
                        cmd.getNameArg("tableName"),
                        cmd.getBoolArg("persists"),
                        cmd.getBoolArg("replaces", true)
                    );

                    if (table) addSpawnTable(table);
                    break;
                case 'addSpawnTableSingleEntry':
                    let entry = HDCoreSpawnTableSingleEntry.create(
                        cmd.getNameArg("name"),
                        cmd.getIntArg("weight")
                    );

                    if (entry) addSpawnTableEntry(
                        cmd.getNameArg("tableName"),
                        entry,
                        cmd.getBoolArg("persists"),
                        cmd.getBoolArg("replaces", true)
                    );
                    break;
                case 'addSpawnTableNestedEntry':
                    let nestedTable = getSpawnTable(
                        cmd.getNameArg("name"),
                        cmd.getBoolArg("persists"),
                        cmd.getBoolArg("replaces", true)
                    );

                    if (nestedTable) {
                        let entry = HDCoreSpawnTableNestedEntry.create(
                            nestedTable,
                            cmd.getIntArg("weight")
                        );
        
                        if (entry) addSpawnTableEntry(
                            cmd.getNameArg("tableName"),
                            entry,
                            cmd.getBoolArg("persists"),
                            cmd.getBoolArg("replaces", true)
                        );
                    }
                    break;
                default:
                    break;
            }
        }
    }

    override void worldLoaded(WorldEvent e) {

        // Populates the main arrays if they haven't been already.
        if (!initialized) init();
    }

    override void checkReplacement(ReplaceEvent e) {

        // Populates the main arrays if they haven't been already.
        if (!initialized) init();

        // If there's nothing to replace or if the replacement is final, quit.
        if (!e.replacee || e.isFinal) return;

        // If thing being replaced is blacklisted, quit.
        foreach (bl : blacklist) if (e.replacee is bl) return;

        // If current map is Range, quit.
        if (Level.MapName == 'RANGE') return;

        handleSpawnReplacements(e, e.replacee.getClassName());
    }

    override void worldThingSpawned(WorldEvent e) {

        // Populates the main arrays if they haven't been already.
        if (!initialized) init();

        // If thing spawned doesn't exist, quit.
        if (!e.thing) return;

        // If thing spawned is blacklisted, quit.
        foreach (bl : blacklist) if (e.thing is bl) return;

        // If current map is Range, quit.
        if (Level.MapName == 'RANGE') return;

        handleSpawns(e.thing, e.thing.getClassName());
    }

    private void handleSpawnReplacements(ReplaceEvent e, name name) {

        // Checks if the level has been loaded more than 1 tic.
        bool prespawn = !(Level.maptime > 1);

        // Iterate through the list of replacement tables for the current thing
        Array<HDCoreSpawnTable> tables;
        tables.clear();

        getSpawnTables(tables, name);
        foreach (table : tables) {

            if (prespawn || table.isPersistent) {
                if (hd_debug) console.printf("Attempting to replace "..name.." with entry in "..table.tableName.."...");

                // If an entry in the table is selected and is replaced successfully, quit.
                if (tryReplaceThing(e, table)) return;
            }
        }
    }

    private void handleSpawns(Actor thing, name name) {

        // Checks if the level has been loaded more than 1 tic.
        bool prespawn = !(level.maptime > 1);

        // Iterate through the list of non-replacement tables for the current thing
        Array<HDCoreSpawnTable> tables;
        tables.clear();

        getSpawnTables(tables, name, false);
        foreach (table : tables) {

            // if currently in pre-spawn or configured to be persistent,
            // and original thing being spawned is not an owned item,
            // and not configured to replace original spawn,
            // attempt to spawn new thing.
            let item = Inventory(thing);
            if ((prespawn || table.isPersistent) && !(item && item.owner)) {
                if (hd_debug) console.printf("Attempting to spawn entry in "..table.tableName.." along with "..name.."...");

                // If an entry in the table is selected and is spawned successfully, quit.
                if (tryCreateThing(thing, table)) return;
            }
        }
    }
}
