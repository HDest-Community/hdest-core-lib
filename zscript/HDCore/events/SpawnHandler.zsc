class HDCoreSpawnTable play {

    // Unique Name of the table.
    name tableName;

    // Name of thing to react to being spawned.
    name spawnName;

    // List of entries of things to spawn.
    Array<HDCoreSpawnTableEntry> entries;

    // Whether or not to use this table beyond initial map spawn.
    bool isPersistent;

    // Whether or not to replace the original thing or just spawn alongside it.
    bool replace;

    /**
     * Creates a spawn table for a given thing by name, as well as an optional unique table name,
     * whether the entries are considered after initial map spawn, and whether the table replaces the original thing.
     * @param {name} spawnName The className of the thing that might spawn.
     * @param {name} [tableName] An optional name to give the table, defaults to spawnName.
     * @param {bool} [persists=false] If true, the table will be considered even after the map has initially spawned all actors.
     * @param {bool} [replace=true] If true, the selected entry in the table will replace the original actor.
     * @returns {HDCoreSpawnTable} The newly created table.
     */
    static HDCoreSpawnTable create(name spawnName, name tableName = '', bool persists = false, bool replace = true) {
        HDCoreSpawnTable table = HDCoreSpawnTable(new('HDCoreSpawnTable'));

        table.tableName = tableName != '' ? tableName : spawnName;
        table.spawnName = spawnName;
        table.isPersistent = persists;
        table.replace = replace;

        return table;
    }

    bool equals(HDCoreSpawnTable other) {
        return (tableName == other.tableName || spawnName == other.spawnName) && isPersistent == other.isPersistent && replace == other.replace;
    }

    string toString() {

        let entriesStr = "[";

        foreach (entry : entries) entriesStr = entriesStr..", "..entry.toString();

        entriesStr = entriesStr.."]";

        return String.format(
            "{ tableName=%s, spawnName=%s, entries=%s, isPersistent=%b, replace=%b }",
               tableName,    spawnName,    entriesStr, isPersistent,    replace
        );
    }

    void addEntry(HDCoreSpawnTableEntry entry) {
        entries.push(entry);
    }

    void addEntries(Array<HDCoreSpawnTableEntry> arr) {
        entries.append(arr);
    }

    void removeEntry(name name) {
        HDCoreSpawnTableEntry tableEntry;
        
        foreach (entry : entries) if (entry.name == name) tableEntry = entry;
        
        entries.delete(entries.find(tableEntry));
    }

    void clearEntries() {
        entries.clear();
    }

    void getWeights(out Array<int> weights) {
        foreach (entry : entries) weights.push(entry.weight);
    }
}

class HDCoreSpawnTableEntry play {

    // Name of thing to spawn
    name name;

    // The relative weight that this thing will spawn within the table
    int weight;

    /**
     * Creates an entry for a given thing by name and its chances of spawning within the table.
     * @param {name} name The className of the thing that might spawn
     * @param {int} chance The relative weight/bias of the thing in the table.
     * @returns {HDCoreSpawnTableEntry} The newly created table entry.
     */
    static HDCoreSpawnTableEntry create(name name, int chance) {
        HDCoreSpawnTableEntry entry = HDCoreSpawnTableEntry(new('HDCoreSpawnTableEntry'));

        entry.name = name;
        entry.chance = chance;

        return entry;
    }

    string toString() {
        return String.format(
            "{ name=%s, chance=%s }",
               name,    chance >= 0
                          ? "1/"..(chance + 1)
                          : "never"
        );
    }
}

class HDCoreSpawnHandler : EventHandler {

    // List of persistent classes to completely ignore.
    // This -should- mean this mod has no performance impact.
    static const string blacklist[] = {
        'HDSmoke',
        'BloodTrail',
        'CheckPuff',
        'WallChunk',
        'HDBulletPuff',
        'HDFireballTail',
        'ReverseImpBallTail',
        'HDSmokeChunk',
        'ShieldSpark',
        'HDFlameRed',
        'HDMasterBlood',
        'PlantBit',
        'HDBulletActor',
        'HDLadderSection'
    };

    // List of all spawn tables.
    array<HDCoreSpawnTable> spawnTables;

    HDCoreSpawnTable getSpawnTable(name name, bool persists = false, bool replace = true) {
        foreach (table : spawnTables) if ((table.tableName == name || table.spawnName == name) && table.isPersistent == persists && table.replace == replace) return table;
    }

    Array<HDCoreSpawnTable> getSpawnTables(name name, bool replace = true) {
        Array<HDCoreSpawnTable> tables;

        foreach (table : spawnTables) if ((table.tableName == name || table.spawnName == name) && table.replace == replace) tables.push(table);

        return tables;
    }

    // Appends the given Spawn Table with the handler, or registers it if it does not yet exist
    void addSpawnTable(HDCoreSpawnTable table) {

        if (hd_debug) {

            let msg = "Adding "
                ..(table.isPersistent ? "Persistent" : "Non-Persistent").." "
                ..(table.replace ? "Replacement" : "Spawning")
                .." Table for "..table.spawnName.." named '"..table.tableName
                .."': [";

            foreach (entry : table.entries) msg = msg..", "..entry.toString();

            console.printf(msg.."]");
        }

        // If we find an existing table, simply append the entries
        foreach (spawnTable : spawnTables) {
            if (table.equals(spawnTable)) {
                spawnTable.entries.append(table.entries);

                return;
            }
        }

        // Otherwise, add the table to the registry.
        spawnTables.push(table);
    }

    // Add a new entry to an existing Spawn Table
    void addSpawnTableEntry(name name, HDCoreSpawnTableEntry entry, bool persists = false, bool replace = true) {
        foreach (spawnTable : getSpawnTables(name, replace)) if (spawnTable.isPersistent == persists) spawnTable.addEntry(entry);
    }

    // Tries to replace the item during spawning.
    bool tryReplaceThing(ReplaceEvent e, HDCoreSpawnTable table) {
        Array<int> weights;
        let entry = table.entries[HDCore.getWeightedRandom(table.getWeights(weights))];

        if (entry && entry.name != e.replacee) {
            if (hd_debug) console.printf(e.replacee.getClassName().." -> "..entry.name);

            e.replacement = entry.name;

            return true;
        }

        return false;
    }

    // Tries to create the Enemy via random spawning.
    bool tryCreateThing(Actor a, HDCoreSpawnTable table) {
        Array<int> weights;
        let entry = table.entries[HDCore.getWeightedRandom(table.getWeights(weights))];

        if (entry && entry.name != a.getClassName()) {
            if (hd_debug) console.printf(a.getClassName().." + "..entry.name);

            Actor.Spawn(entry.name, a.pos);

            return true;
        }

        return false;
    }

    // override void worldLoaded(WorldEvent e) {

    //     // Populates the main arrays if they haven't been already.
    //     if (!cvarsAvailable) init();
    // }

    override void checkReplacement(ReplaceEvent e) {

        // Populates the main arrays if they haven't been already.
        // if (!cvarsAvailable) init();

        // If there's nothing to replace or if the replacement is final, quit.
        if (!e.replacee || e.isFinal) return;

        // If thing being replaced is blacklisted, quit.
        foreach (bl : blacklist) if (e.replacee is bl) return;

        // If current map is Range, quit.
        if (Level.MapName == 'RANGE') return;

        handleSpawnReplacements(e, e.replacee.getClassName());
    }

    override void worldThingSpawned(WorldEvent e) {

        // Populates the main arrays if they haven't been already.
        // if (!cvarsAvailable) init();

        // If thing spawned doesn't exist, quit.
        if (!e.thing) return;

        // If thing spawned is blacklisted, quit.
        foreach (bl : blacklist) if (e.thing is bl) return;

        // If current map is Range, quit.
        if (Level.MapName == 'RANGE') return;

        handleSpawns(e.thing, e.thing.getClassName());
    }

    private void handleSpawnReplacements(ReplaceEvent e, name name) {

        // Checks if the level has been loaded more than 1 tic.
        bool prespawn = !(Level.maptime > 1);

        // Iterate through the list of replacement tables for the current thing
        foreach (table : getSpawnTables(name)) {

            if (prespawn || table.isPersistent) {
                if (hd_debug) console.printf("Attempting to replace "..name.." with entry in "..table.tableName.."...");

                // If an entry in the table is selected and is replaced successfully, quit.
                if (tryReplaceThing(e, table)) return;
            }
        }
    }

    private void handleSpawns(Actor thing, name name) {

        // Checks if the level has been loaded more than 1 tic.
        bool prespawn = !(level.maptime > 1);

        // Iterate through the list of non-replacement tables for the current thing
        foreach (table : getSpawnTables(name, false)) {

            // if currently in pre-spawn or configured to be persistent,
            // and original thing being spawned is not an owned item,
            // and not configured to replace original spawn,
            // attempt to spawn new thing.
            let item = Inventory(thing);
            if ((prespawn || table.isPersistent) && !(item && item.owner)) {
                if (hd_debug) console.printf("Attempting to spawn entry in "..table.tableName.." along with "..name.."...");

                // If an entry in the table is selected and is spawned successfully, quit.
                if (tryCreateThing(thing, table)) return;
            }
        }
    }
}
