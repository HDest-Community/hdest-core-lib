class HDCoreSpawnTable : HDCoreWeightedRandomTable play {

    // Name of thing to react to being spawned.
    HDCoreDataProvider _spawnName;

    // Whether or not to replace the original thing or just spawn alongside it.
    HDCoreDataProvider _replace;

    /**
     * Creates a spawn table for a given thing by name, as well as an optional unique table name,
     * whether the entries are considered after initial map spawn, and whether the table replaces the original thing.
     * @param {name} spawnName The className of the thing that might spawn.
     * @param {name} [tableName] An optional name to give the table, defaults to spawnName.
     * @param {bool} [replace=true] If true, the selected entry in the table will replace the original actor.
     * @returns {HDCoreSpawnTable} The newly created table.
     */
    static HDCoreSpawnTable create(HDCoreDataProvider spawnName, HDCoreDataProvider tableName = null, HDCoreDataProvider replace = null) {
        HDCoreSpawnTable table = HDCoreSpawnTable(new('HDCoreSpawnTable'));

        table._tableName = !!tableName ? tableName : spawnName;
        table._spawnName = spawnName;
        table._replace = replace ? replace : HDCoreDataProvider.create('HDCoreStaticProvider', "true");

        table.clearEntries();

        return table;
    }

    override name getName() {
        if (_tableName && _tableName._value != '') {
            return getTableName();
        } else if (_spawnName && _spawnName._value != '') {
            return getSpawnName();
        } else {
            return '';
        }
    }

    clearscope name getTableName() {
        return _tableName.getNameValue();
    }

    clearscope name getSpawnName() {
        return _spawnName.getNameValue();
    }

    clearscope bool isReplace() {
        return _replace.getBoolValue();
    }

    clearscope bool matches(name name, bool replace = true) {
        return getName() == name && isReplace() == replace;
    }

    override bool equals(HDCoreWeightedRandomTable other) {
        return super.equals(other) && other is 'HDCoreSpawnTable' && isReplace() == HDCoreSpawnTable(other).isReplace();
    }

    override string toString() {

        let entriesStr = "[";

        forEach (entry : _entries) entriesStr = entriesStr..", "..entry.toString();

        entriesStr = entriesStr.."]";

        return String.format(
            "{ \"tableName\": \"%s\", \"spawnName\": \"%s\", \"isReplace\": %i, \"totalWeight\": %.3f, \"entries\": %s }",
                 getTableName(),        getSpawnName(),        isReplace(),    getTotalWeight(_entries), entriesStr
        );
    }

    clearscope static bool shouldGetEntry(HDCoreWeightedRandomTableEntry entry, Dictionary params) {

        HDCoreSpawnTableEntry spawnEntry = HDCoreSpawnTableEntry(entry);

        // If the entry isn't a SpawnTable Entry, or it isn't enabled, skip.
        if (!spawnEntry || !spawnEntry.isEnabled()) {
            // HDCore.Log('HDCoreLib.SpawnTable', LOGGING_DEBUG, "Spawn Table Entry for "..getTableName().." is not enabled, skipping.");

            return false;
        }

        // If entry is not nested, yet has an invalid actor, skip.
        if (spawnEntry is 'HDCoreSpawnTableSingleEntry' && !HDCore.CheckClassExists(spawnEntry.getName())) {
            // HDCore.Log('HDCoreLib.SpawnTable', LOGGING_WARN, "Spawn Table Entry for "..getTableName().." includes a class '"..entry.getName().."' that does not exist!");

            return false;
        }

        // If we're beyond inital map spawns and are not persistent, skip.
        if (params.at("persistentOnly").toInt() && !spawnEntry.isPersistent()) {
            // HDCore.Log('HDCoreLib.SpawnTable', LOGGING_DEBUG, "Spawn Table Entry '"..entry.getName().."' is not persistent, skipping.");

            return false;
        }

        return true;
    }
}

class HDCoreSpawnTableEntry : HDCoreWeightedRandomTableEntry play abstract {

    // Whether or not to use this table beyond initial map spawn.
    HDCoreDataProvider _persistent;

    // Chance out of 256 that the thing being spawned will succeed, otherwise nothing will spawn in its place.
    HDCoreDataProvider _chance;

    // Whether or not this entry should be considered final.
    HDCoreDataProvider _final;

    // Getter to return whether this entry is persistent
    clearscope virtual bool isPersistent() {
        return _persistent.getBoolValue();
    }

    // Getter to return the success chance of this entry
    clearscope virtual int getChance() {
        return _chance.getIntValue();
    }

    // Getter to return whether this entry is final
    clearscope virtual bool isFinal() {
        return _final.getBoolValue();
    }
}

class HDCoreSpawnTableSingleEntry : HDCoreSpawnTableEntry {

    /**
     * Creates an entry for a given thing by name and its chances of spawning within the table.
     * @param {name} name The className of the thing that might spawn.
     * @param {bool{ [enabled=true] if true, the new entry will be included in the table
     * @param {double} [weight=1.0] The relative weight/bias of the thing in the table.
     * @param {bool} [persists=false] If true, the newly created entry will be marked as persistent.
     * @param {int}  [chance=256] chance out of 256 that the thing being spawned will actually spawn.
     * @param {bool} [isFinal=false] If true, the selected entry will be considered final.
     * @returns {HDCoreSpawnTableEntry} The newly created table entry.
     */
    static HDCoreSpawnTableEntry create(
        HDCoreDataProvider name,
        HDCoreDataProvider enabled  = null,
        HDCoreDataProvider weight   = null,
        HDCoreDataProvider persists = null,
        HDCoreDataProvider chance   = null,
        HDCoreDataProvider isFinal  = null
    ) {
        HDCoreSpawnTableSingleEntry entry = HDCoreSpawnTableSingleEntry(new('HDCoreSpawnTableSingleEntry'));

        entry._name       = name;
        entry._enabled    = enabled ? enabled : HDCoreDataProvider.create('HDCoreStaticProvider', "true");
        entry._weight     = weight ? weight : HDCoreDataProvider.create('HDCoreStaticProvider', "1.0");
        entry._persistent = persists ? persists : HDCoreDataProvider.create('HDCoreStaticProvider', "false");
        entry._chance     = chance ? chance : HDCoreDataProvider.create('HDCoreStaticProvider', "256");
        entry._final      = isFinal ? isFinal : HDCoreDataProvider.create('HDCoreStaticProvider', "false");

        return entry;
    }

    override name getValue() {
        let chance = getChance();

        HDCore.log('HDCoreLib.SpawnTableEntry', LOGGING_DEBUG, "Chance of selected Entry '"..getName().."': "..chance.." / 255 ("..(100.0 * clamp(chance, 0, 255) / 255.0).."%)");

        // If a random value (0-255) falls below the success chance, return what's in the entry.
        // Otherwise return a "nothing" dummy spawner to simulate a RandomSpawner picking and failing to drop a thing.
        return (chance > 0 && (chance > 255 || HDCore.getRandomInt(mode: hdc_random_mode) < chance)) ? getName() : 'NullSpawner';
    }

    override void getEntries(out Array<HDCoreWeightedRandomTableEntry> entries) {
        // no-op
    }

    override string toString() {
        return String.format(
            "{ \"name\": \"%s\", \"weight\": %.3f, \"isPersistent\": %i, \"chance\": %i, \"isFinal\": %i }",
                 getName(),        getWeight(),      isPersistent(),       getChance(),    isFinal()
        );
    }
}

class HDCoreSpawnTableNestedEntry : HDCoreSpawnTableEntry {

    HDCoreSpawnTable _table;

    /**
     * Creates an entry for a given thing by name and its chances of spawning within the table.
     * @param {HDCoreSpawnTable} table The Spawn Table to use in this entry.
     * @param {bool{ [enabled=true] if true, the new entry will be included in the table
     * @param {double} [weight=-1.0] The relative weight/bias of the thing in the table. Defaults to the total weight of the table.
     * @param {bool} [persists=false] if true, the new entry is marked as persistent.
     * @param {int} [chance=256] chance out of 256 that the thing being spawned will actually spawn.
     * @param {bool} [isFinal=false] If true, the selected entry will be considered final.
     * @returns {HDCoreSpawnTableEntry} The newly created table entry.
     */
    static HDCoreSpawnTableEntry create(
        HDCoreSpawnTable   table,
        HDCoreDataProvider enabled  = null,
        HDCoreDataProvider weight   = null,
        HDCoreDataProvider persists = null,
        HDCoreDataProvider chance   = null,
        HDCoreDataProvider isFinal  = null
    ) {
        HDCoreSpawnTableNestedEntry entry = HDCoreSpawnTableNestedEntry(new('HDCoreSpawnTableNestedEntry'));

        entry._table = table;

        entry._name       = table._tableName;
        entry._enabled    = enabled ? enabled : HDCoreDataProvider.create('HDCoreStaticProvider', "true");
        entry._weight     = weight ? weight : HDCoreDataProvider.create('HDCoreStaticProvider', "-1.0");
        entry._persistent = persists ? persists : HDCoreDataProvider.create('HDCoreStaticProvider', "false");
        entry._chance     = chance ? chance : HDCoreDataProvider.create('HDCoreStaticProvider', "256");
        entry._final      = isFinal ? isFinal : HDCoreDataProvider.create('HDCoreStaticProvider', "false");

        return entry;
    }

    override double getWeight(Function<clearscope bool(HDCoreWeightedRandomTableEntry, Dictionary)> predicateFn, Dictionary params) {
        let weight = super.getWeight(predicateFn, params);

        if (weight >= 0.0) {
            return weight;
        } else {        
            Array<HDCoreWeightedRandomTableEntry> entries;

            getEntries(entries, predicateFn, params);

            return HDCoreWeightedRandomTable.getTotalWeight(entries, predicateFn, params);
        }
    }

    override name getValue(Function<clearscope bool(HDCoreWeightedRandomTableEntry, Dictionary)> predicateFn, Dictionary params) {
        let entry = _table.getRandomEntry(predicateFn, params);
        let chance = getChance();

        if (entry) HDCore.log('HDCoreLib.SpawnTableEntry', LOGGING_DEBUG, "Chance of selected Entry '"..entry.getName().."': "..chance.." / 255 ("..(100.0 * clamp(chance, 0, 255) / 255.0).."%)");

        // If a random value (0-255) falls below the success chance, return what's in the entry.
        // Otherwise return a "nothing" dummy spawner to simulate a RandomSpawner picking and failing to drop a thing.
        return (entry && chance > 0 && (chance > 255 || HDCore.getRandomInt(mode: hdc_random_mode) < chance)) ? entry.getValue(predicateFn, params) : 'NullSpawner';
    }

    override void getEntries(out Array<HDCoreWeightedRandomTableEntry> entries, Function<clearscope bool(HDCoreWeightedRandomTableEntry, Dictionary)> predicateFn, Dictionary params) {
        _table.getEntries(entries, predicateFn, params);
    }

    override string toString() {
        return String.format(
            "{ \"name\": \"%s\", \"table\": %s, \"weight\": %.3f, \"isPersistent\": %i, \"chance\": %i, \"isFinal\": %i }",
                 getName(), _table.toString(),    getWeight(),      isPersistent(),       getChance(),    isFinal()
        );
    }
}
