class HDCoreSpawnTable play {

    // Unique Name of the table.
    HDCoreDataProvider _tableName;

    // Name of thing to react to being spawned.
    HDCoreDataProvider _spawnName;

    // List of entries of things to spawn.
    Array<HDCoreSpawnTableEntry> _entries;

    // Whether or not to replace the original thing or just spawn alongside it.
    HDCoreDataProvider _replace;

    /**
     * Creates a spawn table for a given thing by name, as well as an optional unique table name,
     * whether the entries are considered after initial map spawn, and whether the table replaces the original thing.
     * @param {name} spawnName The className of the thing that might spawn.
     * @param {name} [tableName] An optional name to give the table, defaults to spawnName.
     * @param {bool} [replace=true] If true, the selected entry in the table will replace the original actor.
     * @returns {HDCoreSpawnTable} The newly created table.
     */
    static HDCoreSpawnTable create(HDCoreDataProvider spawnName, HDCoreDataProvider tableName = null, HDCoreDataProvider replace = null) {
        HDCoreSpawnTable table = HDCoreSpawnTable(new('HDCoreSpawnTable'));

        table._tableName = !!tableName ? tableName : spawnName;
        table._spawnName = spawnName;
        table._replace = replace ? replace : HDCoreDataProvider.create('HDCoreStaticProvider', "true");

        table.clearEntries();

        return table;
    }

    name getName() {
        if (_tableName && _tableName._value != '') {
            return getTableName();
        } else if (_spawnName && _spawnName._value != '') {
            return getSpawnName();
        } else {
            return '';
        }
    }

    name getTableName() {
        return _tableName.getNameValue();
    }

    name getSpawnName() {
        return _spawnName.getNameValue();
    }

    bool isReplace() {
        return _replace.getBoolValue();
    }

    bool matches(name name, bool replace = true) {
        return getName() == name && isReplace() == replace;
    }

    bool equals(HDCoreSpawnTable other) {
        return getName() == other.getName() && isReplace() == other.isReplace();
    }

    string toString() {

        let entriesStr = "[";

        forEach (entry : _entries) entriesStr = entriesStr..", "..entry.toString();

        entriesStr = entriesStr.."]";

        return String.format(
            "{ \"tableName\": \"%s\", \"spawnName\": \"%s\", \"isReplace\": %i, \"totalWeight\": %.3f, \"entries\": %s }",
                 getTableName(),        getSpawnName(),        isReplace(),     getTotalWeight(_entries), entriesStr
        );
    }

    void addEntry(HDCoreSpawnTableEntry entry) {
        HDCore.Log('HDCoreLib.SpawnTable', LOGGING_TRACE, "Adding '"..entry.getName().."' to Spawn Table '"..getTableName().."' Entries...");

        _entries.push(entry);
    }

    void addEntries(Array<HDCoreSpawnTableEntry> arr) {
        HDCore.Log('HDCoreLib.SpawnTable', LOGGING_TRACE, "Appending entries to Spawn Table '"..getTableName().."'...");

        _entries.append(arr);
    }

    void removeEntry(name name) {
        HDCore.Log('HDCoreLib.SpawnTable', LOGGING_TRACE, "Removing '"..name.."' from Spawn Table '"..getTableName().."' Entries...");

        HDCoreSpawnTableEntry tableEntry;

        forEach (entry : _entries) {
            if (entry.getName() == name) {
                HDCore.Log('HDCoreLib.SpawnTable', LOGGING_TRACE, "Entry for '"..entry.getName().."' found.");

                tableEntry = entry;
                break;
            }
        }

        _entries.delete(_entries.find(tableEntry));
    }

    void clearEntries() {
        HDCore.Log('HDCoreLib.SpawnTable', LOGGING_TRACE, "Clearing all entries from Spawn Table '"..getTableName().."'.");

        _entries.clear();
    }

    HDCoreSpawnTableEntry getEntry(name name, bool persistentOnly = false) {
        forEach (entry : _entries) if (entry.getName() == name && (!persistentOnly || entry.isPersistent())) return entry;

        return null;
    }

    void getEntries(out Array<HDCoreSpawnTableEntry> arr, bool persistentOnly = false) {
        arr.clear();

        forEach (entry : _entries) {

            if (!entry || !entry.isEnabled()) {
                HDCore.Log('HDCoreLib.SpawnTable', LOGGING_DEBUG, "Spawn Table Entry for "..getTableName().." is not enabled, skipping.");

                continue;
            }

            // If entry is not nested, yet has an invalid actor, skip.
            if (entry is 'HDCoreSpawnTableSingleEntry' && !HDCore.CheckClassExists(entry.getName())) {
                HDCore.Log('HDCoreLib.SpawnTable', LOGGING_WARN, "Spawn Table Entry for "..getTableName().." includes a class '"..entry.getName().."' that does not exist!");

                continue;
            }

            // If we're beyond inital map spawns and are not persistent, skip.
            if (persistentOnly && !entry.isPersistent()) {
                HDCore.Log('HDCoreLib.SpawnTable', LOGGING_DEBUG, "Spawn Table Entry '"..entry.getName().."' is not persistent, skipping.");

                continue;
            }


            // If weight is negative, treat as only possible outcome (replace all)
            if (entry.getWeight(persistentOnly) < 0.0) {
                HDCore.Log('HDCoreLib.SpawnTable', LOGGING_DEBUG, "'"..entry.getName().."' has negative weight, returning single entry.");

                arr.clear();
                arr.push(entry);
                return;
            }

            // Otherwise, as long as we have a valid weight, add it to array
            if (!HDGMGlobalMaths.nearZero(entry.getWeight(persistentOnly))) {
                HDCore.Log('HDCoreLib.SpawnTable', LOGGING_TRACE, "Adding '"..entry.getName().."' to list of relevant entries.");

                arr.push(entry);
            }
        }

        if (!arr.size()) HDCore.Log('HDCoreLib.SpawnTable', LOGGING_INFO, "No valid entries found for Spawn Table \""..getTableName().."\".");
    }

    HDCoreSpawnTableEntry getRandomEntry(bool persistentOnly = false) {
        HDCore.Log('HDCoreLib.SpawnTableEntry', LOGGING_TRACE, "Getting random entry from Spawn Table '"..getTableName().."'...");

        Array<HDCoreSpawnTableEntry> entries;
        entries.clear();

        getEntries(entries, persistentOnly);

        Array<double> weights;
        weights.clear();

        getWeights(weights, entries, persistentOnly);

        if (HDCore.ShouldLog('HDCoreLib.SpawnTableEntry', LOGGING_DEBUG)) {
            let msg = getTableName().." Entries:\n";
            let totalWeight = getTotalWeight(entries, persistentOnly);
            
            forEach (entry : entries) {
                let weight = entry.getWeight(persistentOnly);

                msg = msg.." * "..entry.getName().." ["..weight.." ("..((weight / totalWeight) * 100.0).."%)]\n";
            }

            HDCore.Log('HDCoreLib.SpawnTableEntry', LOGGING_DEBUG, msg);
        }

        HDCoreSpawnTableEntry entry;

        if (entries.size() > 1) {
            entry = entries[HDCore.getWeightedRandom(weights)];
        } else if (entries.size() > 0) {
            entry = entries[0];
        }
        
        HDCore.Log('HDCoreLib.SpawnTableEntry', LOGGING_DEBUG, "Selected Entry: "..(entry ? "\""..entry.getName().."\"" : "Nothing"));

        return entry;
    }

    static void getWeights(out Array<double> weights, Array<HDCoreSpawnTableEntry> entries, bool persistentOnly = false) {
        weights.clear();

        forEach (entry : entries) weights.push(entry.getWeight(persistentOnly));
    }

    static double getTotalWeight(Array<HDCoreSpawnTableEntry> entries, bool persistentOnly = false) {
        let weight = 0.0;

        forEach (entry : entries) {
            let w = entry.getWeight(persistentOnly);
            if (w > 0.0) {
                weight += w;
            } else {
                return 1.0;
            }
        }

        return weight;
    }
}

class HDCoreSpawnTableEntry play abstract {

    // Whether this entry is currently enabled
    HDCoreDataProvider _enabled;

    // Name of entry.
    // Single Entries are named according to the thing they'll spawn,
    // whereas Nested Entries are named according to their table's name.
    HDCoreDataProvider _name;

    // The relative weight that this entry will spawn within the table
    HDCoreDataProvider _weight;

    // Whether or not to use this table beyond initial map spawn.
    HDCoreDataProvider _persistent;

    // Chance out of 256 that the thing being spawned will succeed, otherwise nothing will spawn in its place.
    HDCoreDataProvider _chance;

    // Whether or not this entry should be considered final.
    HDCoreDataProvider _final;

    virtual bool isEnabled() {
        return _enabled.getBoolValue();
    }

    // Getter to return the name of this entry
    virtual name getName() {
        return _name.getNameValue();
    }

    // Getter to return the weight of this entry
    virtual double getWeight(bool persistentOnly = false) {
        return !persistentOnly || isPersistent()
            ? _weight.getDoubleValue()
            : 0.0;
    }

    // Getter to return whether this entry is persistent
    virtual bool isPersistent() {
        return _persistent.getBoolValue();
    }

    // Getter to return the success chance of this entry
    virtual int getChance() {
        return _chance.getIntValue();
    }

    // Getter to return whether this entry is final
    virtual bool isFinal() {
        return _final.getBoolValue();
    }

    // Getter to return the name of the thing to spawn for this entry
    abstract name getValue(bool persistentOnly = false);

    // Getter to return the relevant list of entries for this 
    abstract void getEntries(out Array<HDCoreSpawnTableEntry> entries, bool persistentOnly = false);

    // Helper method to easily write this entry to the console
    abstract string toString();
}

class HDCoreSpawnTableSingleEntry : HDCoreSpawnTableEntry {

    /**
     * Creates an entry for a given thing by name and its chances of spawning within the table.
     * @param {name} name The className of the thing that might spawn.
     * @param {bool{ [enabled=true] if true, the new entry will be included in the table
     * @param {double} [weight=1.0] The relative weight/bias of the thing in the table.
     * @param {bool} [persists=false] If true, the newly created entry will be marked as persistent.
     * @param {int}  [chance=256] chance out of 256 that the thing being spawned will actually spawn.
     * @param {bool} [isFinal=false] If true, the selected entry will be considered final.
     * @returns {HDCoreSpawnTableEntry} The newly created table entry.
     */
    static HDCoreSpawnTableEntry create(
        HDCoreDataProvider name,
        HDCoreDataProvider enabled  = null,
        HDCoreDataProvider weight   = null,
        HDCoreDataProvider persists = null,
        HDCoreDataProvider chance   = null,
        HDCoreDataProvider isFinal  = null
    ) {
        HDCoreSpawnTableSingleEntry entry = HDCoreSpawnTableSingleEntry(new('HDCoreSpawnTableSingleEntry'));

        entry._name       = name;
        entry._enabled    = enabled ? enabled : HDCoreDataProvider.create('HDCoreStaticProvider', "true");
        entry._weight     = weight ? weight : HDCoreDataProvider.create('HDCoreStaticProvider', "1.0");
        entry._persistent = persists ? persists : HDCoreDataProvider.create('HDCoreStaticProvider', "false");
        entry._chance     = chance ? chance : HDCoreDataProvider.create('HDCoreStaticProvider', "256");
        entry._final      = isFinal ? isFinal : HDCoreDataProvider.create('HDCoreStaticProvider', "false");

        return entry;
    }

    override name getValue() {
        let chance = getChance();

        HDCore.log('HDCoreLib.SpawnTableEntry', LOGGING_DEBUG, "Chance of selected Entry '"..getName().."': "..chance.." / 255 ("..(100.0 * clamp(chance, 0, 255) / 255.0).."%)");

        // If a random value (0-255) falls below the success chance, return what's in the entry.
        // Otherwise return a "nothing" dummy spawner to simulate a RandomSpawner picking and failing to drop a thing.
        return (chance > 0 && (chance > 255 || random() < chance)) ? getName() : 'NullSpawner';
    }

    override void getEntries(out Array<HDCoreSpawnTableEntry> entries) {
        // no-op
    }

    override string toString() {
        return String.format(
            "{ \"name\": \"%s\", \"weight\": %.3f, \"isPersistent\": %i, \"chance\": %i, \"isFinal\": %i }",
                 getName(),        getWeight(),      isPersistent(),       getChance(),    isFinal()
        );
    }
}

class HDCoreSpawnTableNestedEntry : HDCoreSpawnTableEntry {

    HDCoreSpawnTable _table;

    /**
     * Creates an entry for a given thing by name and its chances of spawning within the table.
     * @param {HDCoreSpawnTable} table The Spawn Table to use in this entry.
     * @param {bool{ [enabled=true] if true, the new entry will be included in the table
     * @param {double} [weight=-1.0] The relative weight/bias of the thing in the table. Defaults to the total weight of the table.
     * @param {bool} [persists=false] if true, the new entry is marked as persistent.
     * @param {int} [chance=256] chance out of 256 that the thing being spawned will actually spawn.
     * @param {bool} [isFinal=false] If true, the selected entry will be considered final.
     * @returns {HDCoreSpawnTableEntry} The newly created table entry.
     */
    static HDCoreSpawnTableEntry create(
        HDCoreSpawnTable   table,
        HDCoreDataProvider enabled  = null,
        HDCoreDataProvider weight   = null,
        HDCoreDataProvider persists = null,
        HDCoreDataProvider chance   = null,
        HDCoreDataProvider isFinal  = null
    ) {
        HDCoreSpawnTableNestedEntry entry = HDCoreSpawnTableNestedEntry(new('HDCoreSpawnTableNestedEntry'));

        entry._table = table;

        entry._name       = table._tableName;
        entry._enabled    = enabled ? enabled : HDCoreDataProvider.create('HDCoreStaticProvider', "true");
        entry._weight     = weight ? weight : HDCoreDataProvider.create('HDCoreStaticProvider', "-1.0");
        entry._persistent = persists ? persists : HDCoreDataProvider.create('HDCoreStaticProvider', "false");
        entry._chance     = chance ? chance : HDCoreDataProvider.create('HDCoreStaticProvider', "256");
        entry._final      = isFinal ? isFinal : HDCoreDataProvider.create('HDCoreStaticProvider', "false");

        return entry;
    }

    override name getValue(bool persistentOnly) {
        let entry = _table.getRandomEntry(persistentOnly);
        let chance = getChance();

        HDCore.log('HDCoreLib.SpawnTableEntry', LOGGING_DEBUG, "Chance of selected Entry '"..entry.getName().."': "..chance.." / 255 ("..(100.0 * clamp(chance, 0, 255) / 255.0).."%)");

        // If a random value (0-255) falls below the success chance, return what's in the entry.
        // Otherwise return a "nothing" dummy spawner to simulate a RandomSpawner picking and failing to drop a thing.
        return (entry && chance > 0 && (chance > 255 || random() < chance)) ? entry.getValue() : 'NullSpawner';
    }

    override double getWeight(bool persistentOnly) {
        let weight = _weight.getDoubleValue();
        if (weight >= 0.0) {
            return weight;
        } else {        
            Array<HDCoreSpawnTableEntry> entries;
            entries.clear();

            getEntries(entries, persistentOnly);

            return HDCoreSpawnTable.getTotalWeight(entries, persistentOnly);
        }
    }

    override void getEntries(out Array<HDCoreSpawnTableEntry> entries, bool persistentOnly) {
        _table.getEntries(entries, persistentOnly);
    }

    override string toString() {
        return String.format(
            "{ \"name\": \"%s\", \"table\": %s, \"weight\": %.3f, \"isPersistent\": %i, \"chance\": %i, \"isFinal\": %i }",
                 getName(),  _table.toString(),   getWeight(),      isPersistent(),       getChance(),    isFinal()
        );
    }
}
