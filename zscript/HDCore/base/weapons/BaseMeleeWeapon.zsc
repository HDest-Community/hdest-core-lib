enum BaseMeleeWepNums {

    // Checks whether hitting a textureless pit wall teleports you at the top
    HDCMW_BREAK_FOURTH_WALL = 1,

    // Checks whether hitting an actor in the head deals extra damage/effects
    HDCMW_DO_HEADSHOT       = 2,

    // Checks whether to spawn a puff where the hit connects
    HDCMW_DO_PUFF           = 4,

    // Checks whether to deal sector damage or not
    HDCMW_DO_WALLBUST       = 8,

    // Checks whether to deal extra damage to window panes
    HDCMW_DO_WINDOWBUST     = 16,

    // Checks whether to alter the hit actor's facing angle/pitch
    HDCMW_RECOIL_ATTACKEE   = 32,

    // Checks whether hitting actors will apply buffs
    HDCMW_ZERK_BUFF         = 64,

    // SWING MODE VALUES
    // ----------------
    HDCMW_ATTACK_THRUST     = 0,
    HDCMW_ATTACK_LEFT       = 1,
    HDCMW_ATTACK_RIGHT      = 2,
    HDCMW_ATTACK_UP         = 3,
    HDCMW_ATTACK_DOWN       = 4
}

class HDCoreBaseMeleeWeapon : HDFist abstract {

    // Default Attack Angle/Pitch Offsets
    double angleOffset; property aOff: angleOffset;
    double pitchOffset; property pOff: pitchOffset;

    // Default Puff Actor Class Name
    // name puffType; property puff: puffType;

    // Default Swing Momentum Multipliers
    double swingHorzMult; property swingHMult: swingHorzMult;
    double swingVertMult; property swingVMult: swingVertMult;

    // Default "Dominant Hand Swing" Damage Bonus
    double swingDmgBonus; property swingDmgMult: swingDmgBonus;

    // Default Corpse Damage Bonus
    double corpseDmgBonus; property corpseDmgMult: corpseDmgBonus;

    // Default Attack Flags
    int attackFlags; property attackFlags: attackFlags;

    protected int _swingMode;

    default {

        // Override Fist Vanilla Flags
        -NOINTERACTION
        -Inventory.UNTOSSABLE
        -Weapon.CHEATNOTWEAPON

        // Override Fist HDest Flags
        -HDWeapon.DONTDISARM
        +HDWeapon.FITSINBACKPACK

        // Default Flags
        +FORCEPAIN

        +FORCEXYBILLBOARD
        +ROLLSPRITE
        +ROLLCENTER

        // Default Properties
        damage                              0;
        damageType                          'melee';
        meleeRange                          48.0;
        HDCoreBaseMeleeWeapon.aOff          0.0;
        HDCoreBaseMeleeWeapon.pOff          0.0;
        HDCoreBaseMeleeWeapon.swingHMult    1.0;
        HDCoreBaseMeleeWeapon.swingVMult    1.0;
        HDCoreBaseMeleeWeapon.swingDmgMult  1.6;
        HDCoreBaseMeleeWeapon.corpseDmgMult 1.0;
        HDCoreBaseMeleeWeapon.attackFlags   HDCMW_DO_HEADSHOT|HDCMW_DO_PUFF|HDCMW_DO_WALLBUST|HDCMW_DO_WINDOWBUST|HDCMW_RECOIL_ATTACKEE|HDCMW_ZERK_BUFF;
        // HDCoreBaseMeleeWeapon.puff    '';
    }
    
    override bool AddSpareWeapon(Actor newOwner) {
        return AddSpareWeaponRegular(newOwner);
    }

    override HDWeapon GetSpareWeapon(Actor newOwner, bool reverse, bool doSelect) {
        return GetSpareWeaponRegular(newOwner, reverse, doSelect);
    }

    override inventory CreateTossable(int amt) {
        return HDWeapon.CreateTossable(amt);
    }

    override void DoEffect() {
        if (amount && HDPlayerPawn(owner)) {
            super.doEffect();
        } else {
            HDWeapon.doEffect();
        }
    }

    override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl){
        let ww = HDCoreBaseMeleeWeapon(hdw);
        if (ww.targethealth) sb.drawwepnum(ww.targethealth, ww.targetSpawnHealth);

        if (hd_debug) {
            sb.drawString(sb.pNewSmallFont,
                String.format("Angle: %.2f", hpl.player.cmd.yaw / 360.0),
                (0, -24),
                sb.DI_SCREEN_CENTER_BOTTOM|sb.DI_TEXT_ALIGN_CENTER
            );
            sb.drawString(sb.pNewSmallFont,
                String.format("Pitch: %.2f", hpl.player.cmd.pitch / 360.0),
                (0, -48),
                sb.DI_SCREEN_CENTER_BOTTOM|sb.DI_TEXT_ALIGN_CENTER
            );
        }
    }

    action void A_Lunge(double dist, int fatigueLimit = HDCONST_SPRINTFATIGUE, int stunLimit = 0, double strengthLimit = 0.9, int fatigueIncr = 1, StateLabel abortState = "nope") {
        HDPlayerPawn hdp = HDPlayerPawn(self);
        if (hdp) {
            if (
                hdp.fatigue >= fatigueLimit
                || hdp.stunned > stunLimit
                || hdp.strength < strengthLimit
                || !(player.onGround && checkMove(pos.xy - angleToVector(angle, abs(dist)), PCM_DROPOFF|PCM_NOACTORS))
            ) {
                setWeaponState(abortState);
                return;
            }
            
            hdp.fatigue += fatigueIncr;
            A_Recoil(-abs(dist));
        }
    }

    action void A_MeleeWeaponAttack(int swingMode = HDCMW_ATTACK_DOWN, int dmg = -1, name dmgType = 'None', double aOff = 0.0, int range = -1, double pOff = 0.0, name puffType = 'None', int flags = 0) {
        if (dmg < 0) dmg = invoker.getWeaponDamage();
        if (dmgType == 'None') dmgType = invoker.getWeaponDamageType();
        if (!aOff) aOff = invoker.getWeaponAttackAngleOffset();
        if (range < 0) range = invoker.getWeaponRange();
        if (!pOff) pOff = invoker.getWeaponAttackPitchOffset();
        if (puffType == 'None') puffType = invoker.getWeaponPuff();
        if (!flags) flags = invoker.getWeaponAttackFlags();

        invoker.meleeWeaponAttack(swingMode, dmg, dmgType, aOff, range, pOff, puffType, flags);
    }

    virtual protected double getWeaponAttackFlags() {
        return attackFlags;
    }

    virtual protected double getWeaponAttackHeight() {
        return owner.height * 0.78;
    }

    virtual protected double getWeaponDamage() {
        return damage;
    }

    virtual protected name getWeaponDamageType() {
        return damageType;
    }

    virtual protected double getWeaponAttackAngleOffset() {
        return angleOffset;
    }

    virtual protected double getWeaponRange() {
        return meleeRange;
    }

    virtual protected double getWeaponAttackPitchOffset() {
        return pitchOffset;
    }

    virtual protected double getWeaponHeadShotDamageBonus() {
        return frandom(1.1, 1.8);
    }

    virtual protected int getWeaponHeadShotStun(int dmg) {
        return dmg >> 2;
    }

    virtual protected bool getWeaponLeftHanded() {
        return HDMath.PlayingId();
    }

    virtual protected bool getWeaponDominantSwing(double deltaAngle, double deltaPitch) {
        switch (_swingMode) {
            case HDCMW_ATTACK_LEFT:
                return getWeaponLeftHanded() && deltaAngle > 0 && abs(deltaAngle) > abs(deltaPitch);
            case HDCMW_ATTACK_RIGHT:
                return !getWeaponLeftHanded() && deltaAngle < 0 && abs(deltaAngle) > abs(deltaPitch);
            case HDCMW_ATTACK_UP:
                return deltaPitch > 0 && abs(deltaPitch) > abs(deltaAngle);
            case HDCMW_ATTACK_DOWN:
                return deltaPitch < 0 && abs(deltaPitch) > abs(deltaAngle);
            case HDCMW_ATTACK_THRUST:
                return !(deltaAngle || deltaPitch);
            default:
                return false;
        }
    }

    virtual protected double getWeaponSwingHorzBonus() {
        return swingHorzMult;
    }

    virtual protected double getWeaponSwingVertBonus() {
        return swingVertMult;
    }

    virtual protected double getWeaponSwingDominantBonus() {
        return swingDmgBonus;
    }

    virtual protected double getWeaponSwingDamageBonus(double deltaAngle, double deltaPitch) {
        let iy = max(abs(deltaAngle), abs(deltaPitch));

        // stronger hook from dominant hand
        // TODO: allow passing in flags for left-hand vs right-hand instead of checking id Doom
        if (getWeaponDominantSwing(deltaAngle, deltaPitch)) iy *= getWeaponSwingDominantBonus();

        return abs(iy);
    }

    virtual protected double getWeaponCorpseDamageBonus() {
        return corpseDmgBonus;
    }

    virtual protected string getWeaponPuff() {
        return (strength > 1.5) ? "BulletPuffMedium" : "BulletPuffSmall";
    }

    virtual protected double getWeaponWallBustWidth(double dmg) {
        return dmg * 1.1;
    }

    virtual protected double getWeaponWallBustDepth(double dmg) {
        return dmg * 0.4;
    }

    virtual protected void doFourthWallEscape() {

        // TODO: Localize
        owner.A_Log("PIT DETECTED. FOURTH WALL ALREADY BROKEN. INITIAING EMERGENCY TRANSFER.", true);

        Spawn("Telefog", owner.pos);

        owner.setZ(owner.ceilingZ - owner.height - 5);
        owner.A_ChangeVelocity(2, 0, 2, CVF_RELATIVE);

        Spawn("Telefog", owner.pos);
    }

    virtual protected void doWeaponPuff(name puffType, int aOff, double dist, int pOff) {
        owner.lineAttack(
            owner.angle + aOff, dist, owner.pitch + pOff,
            0,
            "none",
            puffType,
            flags: LAF_NORANDOMPUFFZ|LAF_OVERRIDEZ,
            offsetz: getWeaponAttackHeight()
        );
    }

    virtual protected void doWeaponAttack(Actor attackee, int dmg, name dmgType) {
        attackee.damageMobj(owner, owner, dmg, dmgType);

        targetHealth      = max(0, attackee.health);
        targetSpawnHealth = attackee.spawnHealth();
        targetTimer       = 0;
    
        if (HDCore.shouldLog('HDCore.BaseMeleeWeapon', LOGGING_DEBUG)) {
            name attackeeName = attackee.player
                ? attackee.player.getUserName()..""
                : attackee.getClassName().."";

            HDCore.log('HDCore.BaseMeleeWeapon', LOGGING_DEBUG, "Hit "..attackeeName.." for "..dmg.." damage!");
        }
    }

    virtual protected void doHeadShot(Actor attackee, int dmg) {
        HDCore.log('HDCore.BaseMeleeWeapon', LOGGING_DEBUG, "HEAD SHOT");

        HDMobBase.forcePain(attackee);

        let hdmp = HDMobBase(attackee);
        if (hdmp) hdmp.stunned += getWeaponHeadShotStun(dmg);
    }

    virtual protected void doWeaponHitRecoil(Actor attackee, double deltaAngle, double deltaPitch) {
        if (abs(deltaAngle) > 0.5) attackee.A_SetAngle(clamp(normalize180(attackee.angle - deltaAngle * 100), -50, 50), SPF_INTERPOLATE);
        if (abs(deltaPitch) > 0.5) attackee.A_SetPitch(clamp((attackee.angle + deltaPitch * 100) % 90, -30, 30), SPF_INTERPOLATE);
    }

    virtual protected void doWallBust(double dist, double dmg) {

        bool busted;
        double damageLeft;

        [busted, damageLeft] = DoorDestroyer.destroyDoor(
            owner,
            getWeaponWallBustWidth(dmg),
            getWeaponWallBustDepth(dmg),
            dist,
            getWeaponAttackHeight()
        );

        targetHealth = !(busted || !damageLeft)
            ? int(clamp(1 - damageLeft, 0, 1) * 100)
            : 0;
        targetSpawnHealth = 100;

        if (HDCore.shouldLog('HDCore.BaseMeleeWeapon', LOGGING_DEBUG)) {
            HDCore.log('HDCore.BaseMeleeWeapon', LOGGING_DEBUG, "Hit wall for "..dmg.." damage. "..(busted ? "BUSTED!" : (targetHealth ? targetHealth.."% left." : "UNBUSTABLE!")));
        }
    }

    virtual protected void doWindowBust(FLineTraceData atkLine, double dmg) {
        DoorDestroyer.checkDirtyWindowBreak(atkLine.hitLine, dmg * 0.005, atkLine.hitLocation);
    }

    virtual protected void doAttackSound(Actor attackee) {
        attackee.A_StartSound("misc/bulletflesh", CHAN_BODY);
    }

    virtual protected void doZerkBuff(Actor attackee, bool wasAlive, bool isAlive) {
        if (wasAlive && !isAlive) {
            A_StartSound("weapons/zerkding2", CHAN_WEAPON, CHANF_OVERLAP|CHANF_LOCAL);
            givebody(10);

            // TODO: Localize
            let hdp = HDPlayerPawn(owner);
            if (hdp) {
                hdp.fatigue -= hdp.fatigue >> 2;
                hdp.usegametip("\cfK I L L !");
            }
        } else {
            A_StartSound("weapons/zerkding", CHAN_WEAPON, CHANF_OVERLAP|CHANF_LOCAL);
        }
    }

    protected void meleeWeaponAttack(int swingMode, double dmg, name dmgType = 'melee', int angleOff = 0, double range = 48.0, int pitchOff = 0, name puffType = 'None', int flags = 0) {

        _swingMode = swingMode;

        let hdp = HDPlayerPawn(owner);
        if (hdp) range *= hdp.heightMult;

        // Reset HUD Counters for new attack
        targetHealth = 0;

        FLineTraceData atkLine;
        if (!owner.linetrace(
            owner.angle + angleOff, range, owner.pitch + pitchOff,
            TRF_NOSKY,
            offsetz: getWeaponAttackHeight(),
            data: atkLine
        )) return;

        // the player has fallen into a textureless pit hack. Send them away!
        if (shouldDoFourthWallEscape(atkLine, flags)) doFourthWallEscape();


        // actual puff effect if the shot connects
        if (shouldDoWeaponPuff(flags)) doWeaponPuff(puffType, angleOff, range, pitchOff);

        // Determine camera swing momentum bonus
        double dAngle = (hdp && hdp.player) ? ((hdp.player.cmd.yaw   / 360.0) * getWeaponSwingHorzBonus()) : 0.0;
        double dPitch = (hdp && hdp.player) ? ((hdp.player.cmd.pitch / 360.0) * getWeaponSwingVertBonus()) : 0.0;
        
        // Run Damage Modifications
        dmg = calculateAttackDamage(dmg, atkLine, dAngle, dPitch, flags);

        switch (atkLine.hitType) {
            case TRACE_HitFloor:
                HDCore.log('HDCore.BaseMeleeWeapon', LOGGING_DEBUG, "Melee Attack Hit Floor.");
                onHitFloor(atkLine, dmg, dmgType, dAngle, range, dPitch, flags);
                break;
            case TRACE_HitCeiling:
                HDCore.log('HDCore.BaseMeleeWeapon', LOGGING_DEBUG, "Melee Attack Hit Ceiling.");
                onHitCeiling(atkLine, dmg, dmgType, dAngle, range, dPitch, flags);
                break;
            case TRACE_HitWall:
                HDCore.log('HDCore.BaseMeleeWeapon', LOGGING_DEBUG, "Melee Attack Hit Wall.");
                onHitWall(atkLine, dmg, dmgType, dAngle, range, dPitch, flags);
                break;
            case TRACE_HitActor:
                HDCore.log('HDCore.BaseMeleeWeapon', LOGGING_DEBUG, "Melee Attack Hit '"..atkLine.hitActor.getClassName().."'");
                onHitActor(atkLine, dmg, dmgType, dAngle, range, dPitch, flags);
                break;
            case TRACE_CrossingPortal:
            case TRACE_HasHitSky:
            case TRACE_HitNone:
            default:
                HDCore.log('HDCore.BaseMeleeWeapon', LOGGING_DEBUG, "Melee Attack Missed!");
                onHitNothing(atkLine, dmg, dmgType, dAngle, range, dPitch, flags);
                break;
        }
    }

    virtual protected void onHitFloor(FLineTraceData atkLine, double dmg, name dmgType, double deltaAngle, double range, double deltaPitch, int flags) {

        HDF.Give(owner, "WallChunkAmmo", 1);

        if (shouldDoWallBust(flags)) doWallBust(range, dmg);
    }

    virtual protected void onHitCeiling(FLineTraceData atkLine, double dmg, name dmgType, double deltaAngle, double range, double deltaPitch, int flags) {

        HDF.Give(owner, "WallChunkAmmo", 1);

        if (shouldDoWallBust(flags)) doWallBust(range, dmg);
    }

    virtual protected void onHitWall(FLineTraceData atkLine, double dmg, name dmgType, double deltaAngle, double range, double deltaPitch, int flags) {

        HDF.Give(owner, "WallChunkAmmo", 1);

        if (shouldDoWallBust(flags)) doWallBust(range, dmg);
        if (shouldDoWindowBust(flags)) doWindowBust(atkLine, dmg);
    }

    virtual protected void onHitActor(FLineTraceData atkLine, double dmg, name dmgType, double deltaAngle, double range, double deltaPitch, int flags) {

        // other effects
        if (shouldDoHitRecoil(atkLine, flags)) doWeaponHitRecoil(atkLine.hitActor, deltaAngle, deltaPitch);
        
        // headshot lol
        if (shouldDoHeadShot(atkLine, flags)) doHeadShot(atkLine.hitActor, dmg);

        bool wasAlive = !HDMath.IsDead(atkLine.hitActor);

        // hit sound
        if (shouldDoAttackSound(atkLine, dmg)) doAttackSound(atkLine.hitActor);

        // Deal Damage
        doWeaponAttack(atkLine.hitActor, dmg, dmgType);

        // Perform Berserk Buffs
        if (shouldDoZerkBuff(atkLine, flags)) doZerkBuff(atkLine.hitActor, wasAlive, !HDMath.IsDead(atkLine.hitActor));
    }

    virtual protected void onHitNothing(FLineTraceData atkLine, double dmg, name dmgType, double deltaAngle, double range, double deltaPitch, int flags) {
        // no-op
    }

    virtual protected double calculateAttackDamage(double dmg, FLineTraceData atkLine, double deltaAngle, double deltaPitch, int flags) {

        // If Distraction Punch (kick + punch?)
        // multiply damage by 150%
        // Otherwise add bonus based on facing/distance
        if (flicked) {
            dmg *= 1.5;
        } else {
            dmg += 3.0 * (atkLine.hitActor
                ? HDMath.TowardsEachOther(owner, atkLine.hitActor)
                : (atkLine.hitLocation - owner.pos).length() - (atkLine.hitLocation - (owner.pos + owner.vel)).length()
            );
        }

        dmg += owner.player.onGround ? min(getWeaponSwingDamageBonus(deltaAngle, deltaPitch) * 5, dmg * 3) : 0.0;

        // Multiply damage based on player strength,
        // whether attack resulted in a headshot,
        // and whether the actor hit is dead
        dmg *= (strength * frandom(1.0, 1.2))
            * (atkLine.hitActor && shouldDoHeadShot(atkLine, flags) ? getWeaponHeadShotDamageBonus() : 1.0)
            * (atkLine.hitActor && HDMath.isDead(atkLine.hitActor)) ? getWeaponCorpseDamageBonus() : 1.0;

        return dmg;
    }

    virtual protected bool shouldDoAttackSound(FLineTraceData atkLine, int dmg) {
        return atkLine.hitType == TRACE_HitActor
            && dmg * 2 > atkLine.hitActor.health;
    }

    virtual protected bool shouldDoFourthWallEscape(FLineTraceData atkLine, int flags) {
        return flags&HDCMW_BREAK_FOURTH_WALL
            && atkLine.hitType == TRACE_HitWall
            && atkLine.linePart != 1
            && !atkLine.hitLine.sideDef[atkLine.lineSide].getTexture(atkLine.linePart);
    }

    virtual protected bool shouldDoHeadShot(FLineTraceData atkLine, int flags) {
        return flags&HDCMW_DO_HEADSHOT
            && atkLine.hitType == TRACE_HitActor
            && !atkLine.hitActor.bNOPAIN
            && atkLine.hitActor.health > 0
            && !(HDMobBase(atkLine.hitActor) && HDMobBase(atkLine.hitActor).bHEADLESS)
            && atkLine.hitLocation.z > (atkLine.hitActor.pos.z + atkLine.hitActor.height * 0.75);
    }

    virtual protected bool shouldDoHitRecoil(FLineTraceData atkLine, int flags) {
        return flags&HDCMW_RECOIL_ATTACKEE
            && atkLine.hitType == TRACE_HitActor
            && owner
            && !atkLine.hitActor.bDONTTHRUST
            && (
                atkLine.hitActor.mass < 2 * owner.mass
                || (
                    atkLine.hitActor.radius * 2 < atkLine.hitActor.height
                    && atkLine.hitLocation.z > (atkLine.hitActor.pos.z + atkLine.hitActor.height * 0.6)
                )
            );
    }

    virtual protected bool shouldDoWeaponPuff(int flags) {
        return flags&HDCMW_DO_PUFF;
    }

    virtual protected bool shouldDoWallBust(int flags) {
        return flags&HDCMW_DO_WALLBUST;
    }

    virtual protected bool shouldDoWindowBust(int flags) {
        return flags&HDCMW_DO_WINDOWBUST;
    }

    virtual protected bool shouldDoZerkBuff(FLineTraceData atkLine, int flags) {
        return flags&HDCMW_ZERK_BUFF
            && zerk
            && atkLine.hitType == TRACE_HitActor
            && (atkLine.hitActor.bISMONSTER || atkLine.hitActor.player);
    }

    states {}
}
