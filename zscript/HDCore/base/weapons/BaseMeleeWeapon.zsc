enum BaseMeleeWepNums {

    // Checks whether hitting a textureless pit wall teleports you at the top
    HDCMW_BREAK_FOURTH_WALL = 1,

    // Checks whether hitting an actor in the head deals extra damage/effects
    HDCMW_DO_HEADSHOT       = 2,

    // Checks whether to spawn a puff where the hit connects
    HDCMW_DO_PUFF           = 4,

    // Checks whether to deal sector damage or not
    HDCMW_DO_WALLBUST       = 8,

    // Checks whether to deal extra damage to window panes
    HDCMW_DO_WINDOWBUST     = 16,

    // Checks whether to alter the hit actor's facing angle/pitch
    HDCMW_RECOIL_ATTACKEE   = 32,

    // Checks whether hitting actors will apply buffs
    HDCMW_ZERK_BUFF         = 64
}

class HDCoreBaseMeleeWeapon : HDFist abstract {
    
    default {
        -Inventory.UNTOSSABLE
        -Weapon.CHEATNOTWEAPON

        -HDWeapon.DONTDISARM
        +HDWeapon.FITSINBACKPACK

        +FORCEPAIN
        -NOINTERACTION

        +FORCEXYBILLBOARD
        +ROLLSPRITE
        +ROLLCENTER
    }
    
    override bool AddSpareWeapon(Actor newOwner) {
        return AddSpareWeaponRegular(newOwner);
    }

    override HDWeapon GetSpareWeapon(Actor newOwner, bool reverse, bool doSelect) {
        return GetSpareWeaponRegular(newOwner, reverse, doSelect);
    }

    override inventory CreateTossable(int amt) {
        return HDWeapon.CreateTossable(amt);
    }

    override void DoEffect() {
        if (amount && HDPlayerPawn(owner)) {
            super.doEffect();
        } else {
            HDWeapon.doEffect();
        }
    }

    override void DrawHUDStuff(HDStatusBar sb,HDWeapon hdw,HDPlayerPawn hpl){
        let ww = HDCoreBaseMeleeWeapon(hdw);
        if (ww.targethealth) sb.drawwepnum(ww.targethealth, ww.targetSpawnHealth);
    }

    action void A_Lunge(double dist, int fatigueLimit = HDCONST_SPRINTFATIGUE, int stunLimit = 0, double strengthLimit = 0.9, int fatigueIncr = 1, StateLabel abortState = "nope") {
        HDPlayerPawn hdp = HDPlayerPawn(self);
        if (hdp) {
            if (
                hdp.fatigue >= fatigueLimit
                || hdp.stunned > stunLimit
                || hdp.strength < strengthLimit
                || !(player.onGround && checkMove(pos.xy - angleToVector(angle, abs(dist)), PCM_DROPOFF|PCM_NOACTORS))
            ) {
                setWeaponState(abortState);
                return;
            }
            
            hdp.fatigue += fatigueIncr;
            A_Recoil(-abs(dist));
        }
    }

    action void A_MeleeWeaponAttack(int dmg = -1, name dmgType = 'None', double aOff = 0.0, int range = -1, double pOff = 0.0, int flags = 0) {
        if (dmg < 0) dmg = invoker.getWeaponDamage();
        if (dmgType == 'None') dmgType = invoker.getWeaponDamageType();
        if (!aOff) aOff = invoker.getWeaponAttackAngleOffset();
        if (range < 0) range = invoker.getWeaponRange();
        if (!pOff) pOff = invoker.getWeaponAttackPitchOffset();
        if (!flags) flags = invoker.getWeaponAttackFlags();

        invoker.meleeWeaponAttack(dmg, dmgType, aOff, range, pOff, flags);
    }

    virtual protected double getWeaponAttackFlags() {
        return HDCMW_DO_HEADSHOT|HDCMW_DO_PUFF|HDCMW_DO_WALLBUST|HDCMW_DO_WINDOWBUST|HDCMW_RECOIL_ATTACKEE|HDCMW_ZERK_BUFF;
    }

    virtual protected double getWeaponAttackHeight() {
        return owner.height * 0.78;
    }

    virtual protected double getWeaponDamage() {
        return 0.0;
    }

    virtual protected name getWeaponDamageType() {
        return 'melee';
    }

    virtual protected double getWeaponAttackAngleOffset() {
        return 0.0;
    }

    virtual protected double getWeaponRange() {
        return 48.0;
    }

    virtual protected double getWeaponAttackPitchOffset() {
        return 0.0;
    }

    virtual protected double getWeaponHeadShotDamageBonus() {
        return frandom(1.1, 1.8);
    }

    virtual protected int getWeaponHeadShotStun(int dmg) {
        return dmg >> 2;
    }

    virtual protected bool getWeaponLeftHanded() {
        return HDMath.PlayingId();
    }

    virtual protected bool getWeaponDominantSwing(double rotation, bool leftHanded) {
        return leftHanded ? rotation < 0 : rotation > 0;
    }

    virtual protected double getWeaponSwingHorzBonus() {
        return 1.0;
    }

    virtual protected double getWeaponSwingVertBonus() {
        return 1.0;
    }

    virtual protected double getWeaponSwingDominantBonus() {
        return 1.6;
    }

    virtual protected double getWeaponSwingDamageBonus(double deltaAngle, double deltaPitch) {
        let iy = max(abs(deltaAngle), abs(deltaPitch));

        // stronger hook from dominant hand
        // TODO: allow passing in flags for left-hand vs right-hand instead of checking id Doom
        if (getWeaponDominantSwing(deltaAngle, getWeaponLeftHanded())) iy *= getWeaponSwingDominantBonus();

        return abs(iy);
    }

    virtual protected double getWeaponCorpseDamageBonus() {
        return 1.0;
    }

    virtual protected string getWeaponPuff() {
        return (strength > 1.5) ? "BulletPuffMedium" : "BulletPuffSmall";
    }

    virtual protected double getWeaponWallBustWidth(double dmg) {
        return dmg * 1.1;
    }

    virtual protected double getWeaponWallBustDepth(double dmg) {
        return dmg * 0.4;
    }

    virtual protected void doFourthWallEscape() {

        // TODO: Localize
        owner.A_Log("PIT DETECTED. FOURTH WALL ALREADY BROKEN. INITIAING EMERGENCY TRANSFER.", true);

        Spawn("Telefog", owner.pos);

        owner.setZ(owner.ceilingZ - owner.height - 5);
        owner.A_ChangeVelocity(2, 0, 2, CVF_RELATIVE);

        Spawn("Telefog", owner.pos);
    }

    virtual protected void doWeaponPuff(int aOff, double dist, int pOff) {
        owner.lineAttack(
            owner.angle + aOff, dist, owner.pitch + pOff,
            0,
            "none",
            getWeaponPuff(),
            flags: LAF_NORANDOMPUFFZ|LAF_OVERRIDEZ,
            offsetz: getWeaponAttackHeight()
        );
    }

    virtual protected void doWeaponAttack(Actor attackee, int dmg, name dmgType) {
        attackee.damageMobj(owner, owner, dmg, dmgType);

        targetHealth      = max(0, attackee.health);
        targetSpawnHealth = attackee.spawnHealth();
        targetTimer       = 0;
    
        if (HDCore.shouldLog('HDCore.BaseMeleeWeapon', LOGGING_DEBUG)) {
            name attackeeName = attackee.player
                ? attackee.player.getUserName()..""
                : attackee.getClassName().."";

            HDCore.log('HDCore.BaseMeleeWeapon', LOGGING_DEBUG, "Hit "..attackeeName.." for "..dmg.." damage!");
        }
    }

    virtual protected void doHeadShot(Actor attackee, int dmg) {
        HDCore.log('HDCore.BaseMeleeWeapon', LOGGING_DEBUG, "HEAD SHOT");
        
        HDMobBase.forcePain(attackee);
        
        let hdmp = HDMobBase(attackee);
        if (hdmp) hdmp.stunned += getWeaponHeadShotStun(dmg);
    }

    virtual protected void doWeaponHitRecoil(Actor attackee, double deltaAngle, double deltaPitch) {
        if (abs(deltaAngle) > 0.5) attackee.A_SetAngle(clamp(normalize180(attackee.angle - deltaAngle * 100), -50, 50), SPF_INTERPOLATE);
        if (abs(deltaPitch) > (0.5 * 65535 / 360)) attackee.A_SetPitch(clamp((attackee.angle + deltaPitch * 100) % 90, -30, 30), SPF_INTERPOLATE);
    }

    virtual protected void doWallBust(double dist, double dmg) {

        bool busted;
        double damageLeft;

        [busted, damageLeft] = DoorDestroyer.destroyDoor(
            owner,
            getWeaponWallBustWidth(dmg),
            getWeaponWallBustDepth(dmg),
            dist,
            getWeaponAttackHeight()
        );

        targetHealth = !(busted || !damageLeft)
            ? int(clamp(1 - damageLeft, 0, 1) * 100)
            : 0;
        targetSpawnHealth = 100;

        if (HDCore.shouldLog('HDCore.BaseMeleeWeapon', LOGGING_DEBUG)) {
            HDCore.log('HDCore.BaseMeleeWeapon', LOGGING_DEBUG, "Hit wall for "..dmg.." damage. "..(busted ? "BUSTED!" : (targetHealth ? targetHealth.."% left." : "UNBUSTABLE!")));
        }
    }

    virtual protected void doWindowBust(FLineTraceData atkLine, double dmg) {
        DoorDestroyer.checkDirtyWindowBreak(atkLine.hitLine, dmg * 0.005, atkLine.hitLocation);
    }

    virtual protected void doAttackSound(Actor attackee) {
        attackee.A_StartSound("misc/bulletflesh", CHAN_BODY);
    }

    virtual protected void doZerkBuff(Actor attackee, bool wasAlive, bool isAlive) {
        if (wasAlive && !isAlive) {
            A_StartSound("weapons/zerkding2", CHAN_WEAPON, CHANF_OVERLAP|CHANF_LOCAL);
            givebody(10);

            // TODO: Localize
            let hdp = HDPlayerPawn(owner);
            if (hdp) {
                hdp.fatigue -= hdp.fatigue >> 2;
                hdp.usegametip("\cfK I L L !");
            }
        } else {
            A_StartSound("weapons/zerkding", CHAN_WEAPON, CHANF_OVERLAP|CHANF_LOCAL);
        }
    }

    protected void meleeWeaponAttack(double dmg, name dmgType = 'melee', int angleOff = 0, double range = 48.0, int pitchOff = 0, int flags = 0) {

        let hdp = HDPlayerPawn(owner);
        if (hdp) range *= hdp.heightMult;

        // Reset HUD Counters for new attack
        targetHealth = 0;

        FLineTraceData atkLine;
        if (!owner.linetrace(
            owner.angle + angleOff, range, owner.pitch + pitchOff,
            TRF_NOSKY,
            offsetz: getWeaponAttackHeight(),
            data: atkLine
        )) return;

        // the player has fallen into a textureless pit hack. Send them away!
        if (shouldDoFourthWallEscape(atkLine, flags)) doFourthWallEscape();


        // actual puff effect if the shot connects
        if (shouldDoWeaponPuff(flags)) doWeaponPuff(angleOff, range, pitchOff);

        // Determine camera swing momentum bonus
        double ptch = hdp ? deltaAngle(hdp.lastpitch, hdp.pitch) * getWeaponSwingVertBonus() : 0.0;
        double pyaw = hdp ? deltaAngle(hdp.lastangle, hdp.angle) * getWeaponSwingHorzBonus() : 0.0;
        
        // Run Damage Modifications
        dmg = calculateAttackDamage(dmg, atkLine, pyaw, ptch, flags);

        switch (atkLine.hitType) {
            case TRACE_HitFloor:
                HDCore.log('HDCore.BaseMeleeWeapon', LOGGING_DEBUG, "Melee Attack Hit Floor.");

                HDF.Give(owner, "WallChunkAmmo", 1);

                if (shouldDoWallBust(flags)) doWallBust(range, dmg);

                break;
            case TRACE_HitCeiling:
                HDCore.log('HDCore.BaseMeleeWeapon', LOGGING_DEBUG, "Melee Attack Hit Ceiling.");

                HDF.Give(owner, "WallChunkAmmo", 1);

                if (shouldDoWallBust(flags)) doWallBust(range, dmg);

                break;
            case TRACE_HitWall:
                HDCore.log('HDCore.BaseMeleeWeapon', LOGGING_DEBUG, "Melee Attack Hit Wall.");

                HDF.Give(owner, "WallChunkAmmo", 1);

                if (shouldDoWallBust(flags)) doWallBust(range, dmg);
                if (shouldDoWindowBust(flags)) doWindowBust(atkLine, dmg);

                break;
            case TRACE_HitActor:
                HDCore.log('HDCore.BaseMeleeWeapon', LOGGING_DEBUG, "Melee Attack Hit '"..atkLine.hitActor.getClassName().."'");

                // other effects
                if (shouldDoHitRecoil(atkLine, flags)) doWeaponHitRecoil(atkLine.hitActor, pyaw, ptch);
                
                // headshot lol
                if (shouldDoHeadShot(atkLine, flags)) doHeadShot(atkLine.hitActor, dmg);
        
                bool wasAlive = !HDMath.IsDead(atkLine.hitActor);
        
                // hit sound
                if (shouldDoAttackSound(atkLine, dmg)) doAttackSound(atkLine.hitActor);
        
                // Deal Damage
                doWeaponAttack(atkLine.hitActor, dmg, dmgType);

                // Perform Berserk Buffs
                if (shouldDoZerkBuff(atkLine, flags)) doZerkBuff(atkLine.hitActor, wasAlive, !HDMath.IsDead(atkLine.hitActor));

                break;
            case TRACE_CrossingPortal:
            case TRACE_HasHitSky:
            case TRACE_HitNone:
            default:
                HDCore.log('HDCore.BaseMeleeWeapon', LOGGING_DEBUG, "Melee Attack Missed!");
                break;
        }
    }

    virtual protected double calculateAttackDamage(double dmg, FLineTraceData atkLine, double deltaAngle, double deltaPitch, int flags) {

        // If Distraction Punch (kick + punch?)
        // multiply damage by 150%
        // Otherwise add bonus based on facing/distance
        if (flicked) {
            dmg *= 1.5;
        } else {
            dmg += 3.0 * (atkLine.hitActor
                ? HDMath.TowardsEachOther(owner, atkLine.hitActor)
                : (atkLine.hitLocation - owner.pos).length() - (atkLine.hitLocation - (owner.pos + owner.vel)).length()
            );
        }

        dmg += owner.player.onGround ? min(getWeaponSwingDamageBonus(deltaAngle, deltaPitch) * 5, dmg * 3) : 0.0;

        // Multiply damage based on player strength,
        // whether attack resulted in a headshot,
        // and whether the actor hit is dead
        dmg *= (strength * frandom(1.0, 1.2))
            * (atkLine.hitActor && shouldDoHeadShot(atkLine, flags) ? getWeaponHeadShotDamageBonus() : 1.0)
            * (atkLine.hitActor && HDMath.isDead(atkLine.hitActor)) ? getWeaponCorpseDamageBonus() : 1.0;

        return dmg;
    }

    virtual protected bool shouldDoAttackSound(FLineTraceData atkLine, int dmg) {
        return atkLine.hitType == TRACE_HitActor
            && dmg * 2 > atkLine.hitActor.health;
    }

    virtual protected bool shouldDoFourthWallEscape(FLineTraceData atkLine, int flags) {
        return flags&HDCMW_BREAK_FOURTH_WALL
            && atkLine.hitType == TRACE_HitWall
            && atkLine.linePart != 1
            && !atkLine.hitLine.sideDef[atkLine.lineSide].getTexture(atkLine.linePart);
    }

    virtual protected bool shouldDoHeadShot(FLineTraceData atkLine, int flags) {
        return flags&HDCMW_DO_HEADSHOT
            && atkLine.hitType == TRACE_HitActor
            && !atkLine.hitActor.bNOPAIN
            && atkLine.hitActor.health > 0
            && !(HDMobBase(atkLine.hitActor) && HDMobBase(atkLine.hitActor).bHEADLESS)
            && atkLine.hitLocation.z > (atkLine.hitActor.pos.z + atkLine.hitActor.height * 0.75);
    }

    virtual protected bool shouldDoHitRecoil(FLineTraceData atkLine, int flags) {
        return flags&HDCMW_RECOIL_ATTACKEE
            && atkLine.hitType == TRACE_HitActor
            && owner
            && !atkLine.hitActor.bDONTTHRUST
            && (
                atkLine.hitActor.mass < 2 * owner.mass
                || (
                    atkLine.hitActor.radius * 2 < atkLine.hitActor.height
                    && atkLine.hitLocation.z > (atkLine.hitActor.pos.z + atkLine.hitActor.height * 0.6)
                )
            );
    }

    virtual protected bool shouldDoWeaponPuff(int flags) {
        return flags&HDCMW_DO_PUFF;
    }

    virtual protected bool shouldDoWallBust(int flags) {
        return flags&HDCMW_DO_WALLBUST;
    }

    virtual protected bool shouldDoWindowBust(int flags) {
        return flags&HDCMW_DO_WINDOWBUST;
    }

    virtual protected bool shouldDoZerkBuff(FLineTraceData atkLine, int flags) {
        return flags&HDCMW_ZERK_BUFF
            && zerk
            && atkLine.hitType == TRACE_HitActor
            && (atkLine.hitActor.bISMONSTER || atkLine.hitActor.player);
    }

    states {}
}
